/**
 * generated by Scrooge 3.1.1
 */
package com.twitter.mydemo.renamed

import com.twitter.scrooge.{ThriftStruct, ThriftStructCodec, ThriftStructCodec3}
import java.net.InetSocketAddress
import java.nio.ByteBuffer
import org.apache.thrift.protocol._
import org.apache.thrift.TApplicationException
import scala.collection.mutable
import scala.collection.{Map, Set}
import com.twitter.util.Future
import com.twitter.conversions.time._
import com.twitter.finagle.{Service => FinagleService}
import com.twitter.finagle.stats.{NullStatsReceiver, StatsReceiver}
import com.twitter.finagle.thrift.ThriftClientRequest
import com.twitter.finagle.SourcedException
import com.twitter.finagle.{Service => FinagleService}
import java.util.Arrays
import org.apache.thrift.transport.{TMemoryBuffer, TMemoryInputTransport, TTransport}
import com.twitter.finagle.builder.{Server, ServerBuilder}
import com.twitter.finagle.stats.{StatsReceiver, OstrichStatsReceiver}
import com.twitter.finagle.thrift.ThriftServerFramedCodec
import com.twitter.finagle.tracing.{NullTracer, Tracer}
import com.twitter.logging.Logger
import com.twitter.ostrich.admin.Service
import com.twitter.util.Duration
import java.util.concurrent.atomic.AtomicReference


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"), date = "2013-05-31T12:34:38.929+0100")
object ModulesRepositoryService {
  trait Iface {
    
    def moduleFor(name: String): Html
  }

  trait FutureIface {
    
    def moduleFor(name: String): Future[Html]
  }

  
  object moduleFor$args extends ThriftStructCodec3[moduleFor$args] {
    val Struct = new TStruct("moduleFor_args")
    val NameField = new TField("name", TType.STRING, 1)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: moduleFor$args) {
    }
  
    override def encode(_item: moduleFor$args, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): moduleFor$args = decode(_iprot)
  
    def apply(
      name: String
    ): moduleFor$args = new Immutable(
      name
    )
  
    def unapply(_item: moduleFor$args): Option[String] = Some(_item.name)
  
    object Immutable extends ThriftStructCodec3[moduleFor$args] {
      override def encode(_item: moduleFor$args, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol) = {
        var name: String = null
        var _got_name = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* name */
                _field.`type` match {
                  case TType.STRING => {
                    name = {
                      _iprot.readString()
                    }
                    _got_name = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          name
        )
      }
    }
  
    /**
     * The default read-only implementation of moduleFor$args.  You typically should not need to
     * directly reference this class; instead, use the moduleFor$args.apply method to construct
     * new instances.
     */
    class Immutable(
      val name: String
    ) extends moduleFor$args
  
  }
  
  trait moduleFor$args extends ThriftStruct
    with Product1[String]
    with java.io.Serializable
  {
    import moduleFor$args._
  
    def name: String
  
    def _1 = name
  
    override def write(_oprot: TProtocol) {
      moduleFor$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (true) {
        val name_item = name
        _oprot.writeFieldBegin(NameField)
        _oprot.writeString(name_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      name: String = this.name
    ): moduleFor$args = new Immutable(
      name
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[moduleFor$args]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => name
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "moduleFor$args"
  }
  
  object moduleFor$result extends ThriftStructCodec3[moduleFor$result] {
    val Struct = new TStruct("moduleFor_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: moduleFor$result) {
    }
  
    override def encode(_item: moduleFor$result, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): moduleFor$result = decode(_iprot)
  
    def apply(
      success: Option[Html] = None
    ): moduleFor$result = new Immutable(
      success
    )
  
    def unapply(_item: moduleFor$result): Option[Option[Html]] = Some(_item.success)
  
    object Immutable extends ThriftStructCodec3[moduleFor$result] {
      override def encode(_item: moduleFor$result, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol) = {
        var success: Html = null
        var _got_success = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.STRUCT => {
                    success = {
                      Html.decode(_iprot)
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of moduleFor$result.  You typically should not need to
     * directly reference this class; instead, use the moduleFor$result.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[Html] = None
    ) extends moduleFor$result
  
  }
  
  trait moduleFor$result extends ThriftStruct
    with Product1[Option[Html]]
    with java.io.Serializable
  {
    import moduleFor$result._
  
    def success: Option[Html]
  
    def _1 = success
  
    override def write(_oprot: TProtocol) {
      moduleFor$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        success_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[Html] = this.success
    ): moduleFor$result = new Immutable(
      success
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[moduleFor$result]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "moduleFor$result"
  }

  
  class FinagledClient(
    val service: FinagleService[ThriftClientRequest, Array[Byte]],
    val protocolFactory: TProtocolFactory = new TBinaryProtocol.Factory,
    val serviceName: String = "",
    stats: StatsReceiver = NullStatsReceiver
  ) extends FutureIface {
    // ----- boilerplate that should eventually be moved into finagle:
  
    protected def encodeRequest(name: String, args: ThriftStruct) = {
      val buf = new TMemoryBuffer(512)
      val oprot = protocolFactory.getProtocol(buf)
  
      oprot.writeMessageBegin(new TMessage(name, TMessageType.CALL, 0))
      args.write(oprot)
      oprot.writeMessageEnd()
  
      val bytes = Arrays.copyOfRange(buf.getArray, 0, buf.length)
      new ThriftClientRequest(bytes, false)
    }
  
    protected def decodeResponse[T <: ThriftStruct](resBytes: Array[Byte], codec: ThriftStructCodec[T]) = {
      val iprot = protocolFactory.getProtocol(new TMemoryInputTransport(resBytes))
      val msg = iprot.readMessageBegin()
      try {
        if (msg.`type` == TMessageType.EXCEPTION) {
          val exception = TApplicationException.read(iprot) match {
            case sourced: SourcedException =>
              if (serviceName != "") sourced.serviceName = serviceName
              sourced
            case e => e
          }
          throw exception
        } else {
          codec.decode(iprot)
        }
      } finally {
        iprot.readMessageEnd()
      }
    }
  
    protected def missingResult(name: String) = {
      new TApplicationException(
        TApplicationException.MISSING_RESULT,
        name + " failed: unknown result"
      )
    }
  
    // ----- end boilerplate.
  
    private[this] val scopedStats = if (serviceName != "") stats.scope(serviceName) else stats
    private[this] object __stats_moduleFor {
      val RequestsCounter = scopedStats.scope("moduleFor").counter("requests")
      val SuccessCounter = scopedStats.scope("moduleFor").counter("success")
      val FailuresCounter = scopedStats.scope("moduleFor").counter("failures")
      val FailuresScope = scopedStats.scope("moduleFor").scope("failures")
    }
  
  
    def moduleFor(name: String): Future[Html] = {
      __stats_moduleFor.RequestsCounter.incr()
      this.service(encodeRequest("moduleFor", moduleFor$args(name))) flatMap { response =>
        val result = decodeResponse(response, moduleFor$result)
        val exception =
          None
        exception.orElse(result.success.map(Future.value)).getOrElse(Future.exception(missingResult("moduleFor")))
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_moduleFor.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_moduleFor.FailuresCounter.incr()
        __stats_moduleFor.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
  }
  
  class FinagledService(
    iface: FutureIface,
    protocolFactory: TProtocolFactory
  ) extends FinagleService[Array[Byte], Array[Byte]] {
    // ----- boilerplate that should eventually be moved into finagle:
  
    protected val functionMap = new mutable.HashMap[String, (TProtocol, Int) => Future[Array[Byte]]]()
  
    protected def addFunction(name: String, f: (TProtocol, Int) => Future[Array[Byte]]) {
      functionMap(name) = f
    }
  
    protected def exception(name: String, seqid: Int, code: Int, message: String): Future[Array[Byte]] = {
      try {
        val x = new TApplicationException(code, message)
        val memoryBuffer = new TMemoryBuffer(512)
        val oprot = protocolFactory.getProtocol(memoryBuffer)
  
        oprot.writeMessageBegin(new TMessage(name, TMessageType.EXCEPTION, seqid))
        x.write(oprot)
        oprot.writeMessageEnd()
        oprot.getTransport().flush()
        Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()))
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    protected def reply(name: String, seqid: Int, result: ThriftStruct): Future[Array[Byte]] = {
      try {
        val memoryBuffer = new TMemoryBuffer(512)
        val oprot = protocolFactory.getProtocol(memoryBuffer)
  
        oprot.writeMessageBegin(new TMessage(name, TMessageType.REPLY, seqid))
        result.write(oprot)
        oprot.writeMessageEnd()
  
        Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()))
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    final def apply(request: Array[Byte]): Future[Array[Byte]] = {
      val inputTransport = new TMemoryInputTransport(request)
      val iprot = protocolFactory.getProtocol(inputTransport)
  
      try {
        val msg = iprot.readMessageBegin()
        functionMap.get(msg.name) map { _.apply(iprot, msg.seqid) } getOrElse {
          TProtocolUtil.skip(iprot, TType.STRUCT)
          exception(msg.name, msg.seqid, TApplicationException.UNKNOWN_METHOD,
            "Invalid method name: '" + msg.name + "'")
        }
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    // ---- end boilerplate.
  
    addFunction("moduleFor", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = moduleFor$args.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.moduleFor(args.name)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Html =>
          reply("moduleFor", seqid, moduleFor$result(success = Some(value)))
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("moduleFor", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
  }
  trait ThriftServer extends Service with FutureIface {
    val log = Logger.get(getClass)
  
    def thriftCodec = ThriftServerFramedCodec()
    def statsReceiver: StatsReceiver = new OstrichStatsReceiver
    def tracerFactory: Tracer.Factory = NullTracer.factory
    val thriftProtocolFactory: TProtocolFactory = new TBinaryProtocol.Factory()
    val thriftPort: Int
    val serverName: String
  
    // Must be thread-safe as different threads can start and shutdown the service.
    private[this] val _server = new AtomicReference[Server]
    def server = _server.get
    def server_=(value: Server) = _server.set(value)
  
    def start() {
      val thriftImpl = new FinagledService(this, thriftProtocolFactory)
      server_=(serverBuilder.build(thriftImpl))
    }
  
    /**
     * You can override this to provide additional configuration
     * to the ServerBuilder.
     */
    def serverBuilder =
      ServerBuilder()
        .codec(thriftCodec)
        .name(serverName)
        .reportTo(statsReceiver)
        .bindTo(new InetSocketAddress(thriftPort))
        // TODO: once everyone in Twitter is on Finagle 6+, change this to
        // .tracer(tracerFactory())
        .tracerFactory(tracerFactory)
  
    /**
     * Close the underlying server gracefully with the given grace
     * period. close() will drain the current channels, waiting up to
     * ``timeout'', after which channels are forcibly closed.
     */
    def shutdown(timeout: Duration = 0.seconds) {
      synchronized {
        val s = server
        if (s != null) {
          s.close(timeout)
        }
      }
    }
  
    def shutdown() = shutdown(0.seconds)
  }
}